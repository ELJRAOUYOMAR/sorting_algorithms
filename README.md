# sorting_algorithms



## Introduction

Sorting algorithms are fundamental tools in computer science and programming. They allow us to organize data in a specific order, making it easier to search, analyze, and manipulate. There are various sorting algorithms, each with its own characteristics, advantages, and disadvantages. Understanding different sorting algorithms and their efficiency is crucial for writing efficient code and solving real-world problems effectively.

This project explores different sorting algorithms, implementing them in various programming languages and providing insights into their performance and usage.

## Bubble Sort

### Introduction

Bubble sort is one of the simplest sorting algorithms. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. Although bubble sort is easy to understand and implement, it is not efficient for large lists and is rarely used in practice for performance reasons.

### Big O Notation

- Best Case: O(n)
- Average Case: O(n^2)
- Worst Case: O(n^2)

## Selection Sort

### Introduction

Selection sort is another simple sorting algorithm that divides the input list into two parts: the sublist of items already sorted and the sublist of items remaining to be sorted. It repeatedly finds the minimum element from the unsorted part and moves it to the beginning of the sorted part. Like bubble sort, selection sort is straightforward to implement but inefficient for large datasets.

### Big O Notation

- Best Case: O(n^2)
- Average Case: O(n^2)
- Worst Case: O(n^2)

## Shell Sort - Knuth Sequence

### Introduction

Shell sort, also known as Shell's method, is an extension of the insertion sort algorithm. It improves upon insertion sort's efficiency by comparing elements that are far apart first, rather than adjacent elements, and then progressively reducing the gap between elements to be compared. The Knuth sequence, proposed by Donald Knuth, is commonly used to determine the gap sequence in Shell sort.

### Knuth Sequence

The Knuth sequence is a sequence of integers defined recursively as follows:

h(1) = 1
h(n+1) = 3 * h(n) + 1


The sequence generated by this recurrence relation is commonly used as the gap sequence in Shell sort. Starting with the largest gap, Shell sort performs multiple insertion sorts on the subarrays formed by the gap sequence, gradually reducing the gap until it becomes 1, at which point the array is completely sorted.

### Example

Let's illustrate the Shell sort algorithm using the Knuth sequence on an array:


Array: 19, 48, 99, 71, 13, 52, 96, 73, 86, 7

Gap: 4
Result: 13, 7, 96, 71, 19, 48, 99, 73, 86, 52

Gap: 1
Result: 7, 13, 19, 48, 52, 71, 73, 86, 96, 99

### Implementation Details

In the implementation of Shell sort with the Knuth sequence, the gap is calculated using the Knuth sequence, and the algorithm iteratively reduces the gap until it becomes 1. At each step, insertion sort is performed within the gap, gradually sorting the array.

```c
void shell_sort(int *array, size_t size) {
    size_t gap = 1, i, j;
    int temp;

    while (gap < size / 3)
        gap = gap * 3 + 1;

    while (gap > 0) {
        for (i = gap; i < size; i++) {
            temp = array[i];
            j = i;

            while (j >= gap && array[j - gap] > temp) {
                array[j] = array[j - gap];
                j -= gap;
            }

            array[j] = temp;
        }

        gap = (gap - 1) / 3;
    }
}
```
